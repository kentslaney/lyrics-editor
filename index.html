<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="manifest" href="manifest.json" />
<link rel="icon" type="image/png" href="icons/512.png">
<script type="text/javascript">
class Cursor {
    url = "https://raw.githubusercontent.com/Alexir/CMUdict/master/cmudict-0.7b"
    local = "cmudict-0.7b"
    lexicon = 125770

    #db;
    constructor() {
        this.create()
    }

    create() {
        const request = indexedDB.open("words", 1);
        let done;
        this.loading = new Promise((resolve, reject) => done = resolve)
        this.loaded = new Promise((resolve, reject) => this.status = s => {
            this.status = s => {}
            resolve(s)
        })

        request.onupgradeneeded = (event) => {
            const db = event.target.result
            db.createObjectStore("pronunciations", { keyPath: 'word' });
            const store = db.createObjectStore("status", { keyPath: 'id' });
            store.add({ id: "loaded", value: false })
            store.add({ id: "url", value: this.url })
        };

        request.onsuccess = (event) => {
            this.#db = event.target.result
            const tx = this.#db.transaction("status", "readonly")
            const store = tx.objectStore("status")
            store.get("loaded").onsuccess = (async function(event) {
                const res = event.target.result.value
                const ws = await this.remoteAvailable
                if (res || ws) this.status(res)
                done(res)
            }).bind(this)
        }
    }

    async clear() {
        return new Promise((resolve, reject) => {
            this.#db.close()
            const tx = indexedDB.deleteDatabase("words")
            tx.onsuccess = () => {
                this.create()
                resolve()
            }
            tx.onblocked = tx.onerror = e => {
                reject(e.target.error)
            }
        })
    }

    async load(progress = () => {}, storing = () => {}) {
        const db = this.#db, lexicon = this.lexicon, commits = [];
        console.info("populating pronunciation db")
        return fetch((await this.remoteAvailable) ? this.local : this.url)
            .then((response) => {
                if (!response.ok) {
                    reject(response)
                }
                return response.body.getReader();
            })
            .then(async function(reader) {
                let prefix = "", existing = [], prev = "", total = 0
                const pump = async () => {
                    const { done, value } = await reader.read();

                    const tx = db.transaction("pronunciations", 'readwrite');
                    const store = tx.objectStore("pronunciations");

                    const textChunk = new TextDecoder().decode(value);
                    const text = prefix + textChunk
                    let line = undefined;
                    for (let next of text.split("\n")) {
                        if (line === undefined || line.startsWith(";;;")) {
                            line = next;
                            continue;
                        }
                        const [pre] = line.split(" ", 1)
                        const post = line.slice(pre.length)
                        const [word, version] = (pre.endsWith(")") ?
                            pre.slice(0, -1).split("(") : [pre, "0"])
                        if (word !== prev) {
                            if (prev) {
                                commits.push(new Promise((resolve, reject) => {
                                    const op = store.add({
                                        word: prev,
                                        pronunciation: existing
                                    });
                                    op.onsuccess = resolve
                                    op.onerror = reject
                                }))
                                existing = []
                                total++
                            }
                            prev = word
                        }
                        existing.push(post.trim())
                        line = next
                    }
                    prefix = line
                    if (!done) {
                        console.info("downloaded", total, "of", lexicon,
                            "rows; % complete:",
                            Math.round(total / lexicon * 1000) / 10)
                        progress(total, lexicon)
                        return pump()
                    }
                    commits.push(new Promise((resolve, reject) => {
                        const op = store.add({
                            word: prev,
                            pronunciation: existing
                        });
                        op.onsuccess = resolve
                        op.onerror = reject
                    }))
                    console.assert(++total === lexicon) // TODO
                    console.info("pronunciation db downloaded")
                };
                return pump();
            })
            .then(storing)
            .then(() => Promise.allSettled(commits))
            .then((() => {
                console.info("pronunciation db populated")
                const tx = db.transaction("status", 'readwrite');
                const store = tx.objectStore("status");
                store.put({ id: "loaded", value: true });
                this.loaded = new Promise((resolve, reject) => resolve(true))
                this.status(true)
            }).bind(this))
    }

    localLookup(query) {
        const tx = this.#db.transaction("pronunciations", 'readonly');
        const store = tx.objectStore("pronunciations");
        const request = store.get(query.toUpperCase())
        return new Promise((resolve, reject) => {
            request.onsuccess = event =>
                resolve(event.target.result?.pronunciation)
            request.onerror = reject
        })
    }

    #encodeURI(query) {
        return typeof query === "string" ? query : JSON.stringify(query)
    }

    async remoteLookup(query) {
        const socket = new WebSocket("ws://localhost:8080/ws");
        let requests = []
        socket.addEventListener("message", e => {
            requests.pop(0)(JSON.parse(e.data))
        })
        let opener, open = new Promise((resolve, reject) => opener = resolve)
        socket.addEventListener("open", opener)
        this.remoteLookup = async function(query) {
            await open
            let res = new Promise((resolve, reject) => requests.push(resolve))
            socket.send(this.#encodeURI(query))
            return res
        }
        return this.remoteLookup(query)
    }

    reformatRemote(response) {
        return response.length === 0 ? undefined : response.map(x => x[2])
    }

    get remoteAvailable() {
        return new Promise((resolve, reject) => {
            const f = () => resolve("ws_available" in window)
            if (document.readyState !== "loading") f()
            else document.addEventListener("load", f)
        })
    }

    async lookup(query) {
        const single = typeof query === "string"
        if (single ? query === "" : !query.filter(x => x).length)
            return single ? undefined :
                [...new Array(query.length).keys()].map(x => undefined)
        if (await this.loaded) {
            if (single) {
                return this.localLookup(query)
            } else {
                const queries = query.map(
                    x => x === "" ? undefined : this.localLookup(x))
                let res = []
                for await (const i of queries) {
                    res.push(i)
                }
                return res
            }
        } else {
            const res = await this.remoteLookup(query)
            if (single) return this.reformatRemote(res)
            else return res.map(this.reformatRemote)
        }
    }
}

const dict = new Cursor()

// https://ismir2009.ismir.net/proceedings/OS8-1.pdf
// https://roa.rutgers.edu/files/377-0200/377-0200-YIP-0-0.PDF
class Similarities {
    constructor() {
        fetch("/OS8-1.json").then(res => res.json()).then((res => {
            for (const key of Object.keys(res)) {
                this[key] = res[key]
            }
            this.axes = {}
            this.group = {}
            for (const [symbol, value] of this.symbols) {
                const mapped = this.mapping[value]
                this.group[symbol] = [mapped, null]
                if (!mapped) continue
                if (mapped in this.axes) this.axes[mapped].push(symbol)
                else this.axes[mapped] = [symbol]
                this.group[symbol][1] = this.axes[mapped].length - 1
            }
        }).bind(this))
    }

    lookup(term0, term1) {
        const [type0, index0] = this.group[term0]
        if (term1 === undefined) {
            const res = this[type0].slice(0, index0).map(x => x[index0]).concat(
                this[type0][index0])
            return Object.fromEntries(
                this.axes[type0].map((a, b) => [a, res[b]]))
        } else {
            const [type1, index1] = this.group[term1]
            if (type0 === null || type0 !== type1) return null
            const [lo, hi] = [index0, index1].toSorted((a, b) => a - b)
            return this[type0][lo][hi - lo]
        }
    }
}

class Edit {
    constructor(iter0, iter1, n = undefined, m = undefined) {
        this.iter0 = iter0
        this.iter1 = iter1
        this.n = n === undefined ? iter0.length : n
        this.m = m === undefined ? iter1.length : m
        this.dp = [...Array(this.n + 1).keys()].map(x => {
            return [...Array(this.m + 1).keys()].map(y => null)
        })
    }

    _path = null
    get path() {
        if (this._path === null) return this._path = this.loader(this.n, this.m)
        return this._path
    }

    // n shift is lowest bit, m shift is next
    loader(n, m) {
        if (n == 0) return [...Array(m).keys()].map(x => 2);
        if (m == 0) return [...Array(n).keys()].map(x => 1);
        if (this.dp[n][m] !== null) return this.dp[n][m];
        if (this.iter0[n - 1] == this.iter1[m - 1]) {
            let prev = this.dp[n - 1][m - 1]
            if (prev === null) prev = this.loader(n - 1, m - 1)
            return this.dp[n][m] = prev.concat([0])
        }
        let options = []
        for (let i = 1; i < 4; i++) {
            const j = n - (i & 1), k = m - (i & 2) / 2
            let prev = this.dp[j][k]
            if (prev === null) prev = this.loader(j, k)
            options.push(prev.concat([i]))
        }
        const min = options.toSorted((a, b) => {
            const [c, d] = [a, b].map(x => x.reduce((c, d) => c + (d !== 0), 0))
            return c - d
        })[0]
        return this.dp[n][m] = min
    }

    walk(f, arr, bit) { // f(element, rewritten, index)
        for (let i = 0, d = 0; i < arr.length; i++) {
            const x = this.path[i]
            if ((x & bit) === bit) f(arr[i - d], x === 3, i - d)
            d += (x === (bit ^ 3))
        }
    }

    removed(f) {
        return this.walk(f, this.iter0, 1)
    }

    added(f) {
        return this.walk(f, this.iter1, 2)
    }
}

class Editing {
    value = ""
    words = []
    pronunciations = []
    constructor(cursor) {
        this.cursor = cursor
    }

    strip = /[^a-zA-Z']/g
    split = /[\s\-_]/g

    async update(value) {
        const words = value.split(this.split).map(
            x => x.replace(this.strip, ""))
        const edit = new Edit(this.words, words)
        this.words = words
        this.value = value
        let added = [], idx = []
        edit.added((x, rewrite, i) => {
            added.push(x)
            idx.push([i, rewrite])
        })
        let res = await this.cursor.lookup(added)
        let removing = []
        edit.removed((x, rewrite, i) => {
            if (!rewrite) removing.splice(0, 0, i)
        })
        for (let i of removing) {
            this.pronunciations.splice(i, 1)
        }
        res.forEach((i, j) => {
            let [next, rewrite] = idx[j]
            this.pronunciations.splice(next, rewrite ? 1 : 0, i)
        })
        console.assert(this.pronunciations.length === words.length)
    }

    get separators() {
        const res = this.value.match(this.split)
        return res === null ? [] : res
    }

    get raw() {
        return this.value.split(this.split)
    }
}

function debounce(ms, f) {
    request_controller = null
    return (...args) => {
        if (request_controller !== null) {
            request_controller.abort();
        }
        request_controller = new AbortController();
        const signal = request_controller.signal;
        setTimeout(() => {
            if (signal.aborted) return;
            f(...args)
        }, ms);
    }
}

class DoubleSpaced {
    debounce_ms = 1000
    constructor(cursor, wrapper, load = true) {
        this.editor = new Editing(cursor)
        this.wrapper = wrapper
        this.foreground = this.wrapper.getElementsByClassName("foreground")[0]
        this.background = this.wrapper.getElementsByClassName("background")[0]
        const hide = this.wrapper.appendChild(document.createElement("div"))
        hide.classList.add("container")
        this.reference = hide.appendChild(document.createElement("div"))
        this.reference.classList.add("reference")
        this.foreground.addEventListener("input", this.update.bind(this))
        this.foreground.addEventListener("input", this.save.bind(this))
        this.foreground.addEventListener("input", debounce(
            this.debounce_ms, this.parse.bind(this)))
        new ResizeObserver(this.resize.bind(this)).observe(this.reference)
        if (load) this.load()
        this.update()
        this.parse()
    }

    save() {
        window.localStorage["saved"] = this.foreground.value
    }

    loaded = false
    load() {
        if ("saved" in window.localStorage) {
            this.foreground.value = window.localStorage["saved"]
            this.loaded = true
        }
    }

    update() {
        this.reference.innerText = this.foreground.value
    }

    resize(e) {
        this.foreground.style.height =
            this.reference.getBoundingClientRect().height + "px"
    }

    async parse() {
        this.editor.update(this.foreground.value).then(() => {
            const limits = this.editor.raw.map(x => x.length)
            const padded = this.editor.raw.concat([""])
            const sep = this.editor.separators.map((x, i) => {
                if ("\n ".includes(x)) return x
                const next = padded[i + 1].slice(0, 1)
                const wordish = next.length && !next.match(this.editor.strip)
                return wordish ? "\xA0\u200B" : "\xA0"
            }).concat([""])
            this.background.innerText = this.parser(limits).map((x, i) => {
                console.assert(x.length <= limits[i])
                return x.padStart(limits[i]) + sep[i]
            }).join("")
            this.wrapper.style.minHeight =
                this.foreground.getBoundingClientRect().height + "px";
        })
    }

    fill = "\xa0"
    parser(limits) {
        const options = this.editor.pronunciations.map(x => x?.map(y =>
            y.replace(/[^012]/g, "").replace(/[12]/g, "/").replace(/0/g, "X")))
        return options.map((x, i) => {
            if (!x) return this.editor.raw[i] ? "?" : ""
            const match = this.editor.raw[i].match(/\(([0-9]+)\)$/)
            if (match) return x[parseInt(match[1])]
            return x.reduce((a, b) => {
                return a.split('').map((y, j) => y === b[j] ? y : "\\").join('')
            })
        }).map((x, i) => {
            const whitespace = limits[i] - x.length
            const lo = Math.trunc(whitespace / (x.length + 1))
            const wide = whitespace % (x.length + 1)
            const res = x.split('').map((y, j) => {
                return y + this.fill.repeat(lo + (j < wide))
            }).join('')
            return this.fill.repeat(lo) + res
        })
    }

    firstFocus() {
        const size = this.editor.value.length
        if (!this.loaded) this.foreground.setSelectionRange(0, size);
    }
}

let ed

const [ firstFocus, focusCallback ] = (() => {
    let callback, waiter = new Promise((resolve, reject) => callback = resolve)
    let first = async function() {
        first = async function() {}
        if (ed !== undefined) return ed.firstFocus()
        await waiter
        ed.firstFocus()
    }
    return [() => first(), callback]
})()

window.addEventListener("load", async function() {
    const pre = document.getElementsByClassName("double-spaced")[0]
    ed = new DoubleSpaced(dict, pre)
    focusCallback()
    const status = document.getElementById("load-status")
    const button = document.getElementById("load-dict")
    const download = () => {
        button.style.display = "none"
        status.innerText = "being downloaded"
        dict.load((portion, total) => {
            status.innerText = `being downloaded (${portion} of ${total})`
        }, () => status.innerText = "being stored").then(() => {
            status.innerText = "local"
        }).catch(e => {
            status.innerText = "remote (download failed)"
            button.style.display = "initial"
            button.innerText = "retry"
        })
    }
    if (await dict.loading) status.innerText = "local"
    else if (!(await dict.remoteAvailable)) download()
    else {
        status.innerText = "remote"
        button.style.display = "initial"
        button.addEventListener("click", download)
    }
    const clear = document.getElementById("clear-state")
    const clearStatus = document.getElementById("clear-status")
    clear.addEventListener("click", () => {
        delete window.localStorage["saved"]
        clearStatus.innerText = "clearing..."
        dict.clear().then(() => {
            clearStatus.innerText = ""
            status.innerText = "remote"
            button.style.display = "initial"
        }).catch(e => {
            clearStatus.innerText = "clear operation failed"
            throw e
        })
    })
})
</script>
</head>
<body>
    <div class="double-spaced">
        <textarea class="foreground" name="main" onfocus="firstFocus()">
Haikus are easy
But sometimes(1) they don't make sense
Refrigerator</textarea>
        <div class="background"></div>
    </div>
    <div id="page-status">
        <br />
        words list is <span id="load-status">...</span>
        <button id="load-dict">download</button>
        <div id="debug-clear">
            <br />
            <button id="clear-state">clear state</button>
            <span id="clear-status"></span>
        </div>
    </div>
<style>
.foreground, .background, .reference {
    line-height: 2.5;
    margin: 0;
    font-family: monospace;
    white-space: pre-wrap;
    padding-left: 0.5em;
    padding-right: 0.5em;
}

.foreground {
    font-size: inherit;
    padding-top: 1em;
    padding-bottom: 0;
    outline: 0;
    width: calc(100% - 1em);
    border-width: 0;
    resize: none;
    overflow: hidden;
    background: transparent;
    display: block;
}

.background {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    z-index: -1;
}

.double-spaced:focus-within {
    border-color: blue;
}

.double-spaced {
    position: relative;
    overflow: hidden;
    border: 1px solid #000;
}

.container {
    height: 0;
    overflow: hidden;
}

.reference::before, .reference::after {
    content: '\200C'
}

#load-dict {
    display: none;
}

#debug-clear {
    display: none;
}

body {
    font-size: 1rem;
}

@media not (any-pointer: fine) {
    .double-spaced {
        border-width: 0 0 1px 0;
        border-color: #000 !important;
        padding-bottom: 0.5em;
    }
}

@media print {
    .double-spaced {
        border-width: 0 !important;
    }

    .foreground {
        display: none;
    }

    .container {
        height: initial;
    }

    .background, .reference {
        padding: 0;
    }

    .reference {
        transform: translateY(1em);
        padding-bottom: 1em;
    }

    #page-status {
        display: none;
    }

    body {
        font-size: 1.5rem;
    }
}
</style>
</body>
</html>
